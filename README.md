## Архитектура ПО

### UML диаграмма классов

UML происходит от Unified Modeling Language, 
если по- русски, то — унифицированный язык моделирования.  

Видео разбор [UML Диаграмма Классов](https://www.youtube.com/watch?v=sVVJp5a41o4&t=11s)

[Полное руководство по диаграмме классов UML](https://www.cybermedian.com/ru/a-comprehensive-guide-to-uml-class-diagram/#Ogromnaa_kollekcia_BESPLATNYH_ucebnyh_resursov_pri_podderzke_VP_Community_Circle)

[UML для самых маленьких: диаграмма классов](https://habr.com/ru/articles/511798/)

Кратность или Множественность

0...n  
1...*  
0...*  

### Паттерн фабричный метод

Порождающий шаблон проектирования фабричный метод:

Который предоставляет дочерним классам интерфейс
для создания экземпляров некоторого класса.
В момент создания наследники могут определить какой класс создавать.
Иными словами данный шаблон делегирует создание
объектов наследником родительского класса.
Это позволяет использовать в коде программы не специфические классы
а манипулировать абстрактными объектами на более высоком уровне.

Достоинства фабричного метода:
позволяет сделать код создания объектов более
универсальным не привязываясь к конкретным
классам, а оперируя лишь общим интерфейсом.
Позволяет установить связь между
параллельными иерархиями классов.

Недостатком паттерна является
необходимость создавать наследника для
каждого нового типа.

<details> 
  <summary>Фабричный метод (Factory Method)</summary>
Это порождающий паттерн проектирования, который определяет общий
интерфейс для создания объектов в суперклассе, позволяя подклассам
изменять тип создаваемых объектов.
Метод фабрики считается креативным паттерном проектирования, то есть
связанным с созданием объектов. В паттерне «Фабрика» мы создаём объект,
не раскрывая логики создания клиенту, а клиент использует тот же общий
интерфейс для создания нового типа объекта.
Паттерн «Фабрика» вводит свободную связь между классами, что считается
наиболее важным принципом, который необходимо учитывать и применять
при проектировании архитектуры приложения. Свободная связь может быть
введена в архитектуру приложения путём программирования на основе
абстрактных сущностей, а не конкретных реализаций. Это делает нашу
архитектуру не только более гибкой, но и менее хрупкой.

Назначение
Определяет интерфейс для создания объекта, но оставляет подклассам
решение, какой класс инстанцировать. Фабричный метод позволяет классу
делегировать инстанцирование подклассам.

Проблема
Представим, что требуется создать программу управления грузовыми
перевозками. Изначально перевозки осуществляются на грузовых
автомобилях, поэтому весь код работает с объектами класса «Грузовик».
В какой-то момент программой заинтересовались морские перевозчики. Но
большая часть кода привязана к классу «Грузовик». Чтобы добавить в
программу классы морских судов, надо исправить большую часть кода.
Изменения будут требоваться каждый раз при добавлении нового вида
транспорта.
Таким образом, получится очень большой код, наполненный условными
операторами, определяющими тип транспорта.

Применимость  
Паттерн «Фабричный метод» стоит использовать:  
● когда заранее неизвестны типы и зависимости объектов, с которыми
работает код;  
● когда хотим дать возможность пользователям расширять части нашего
фреймворка или библиотеки;  
● когда требуется экономить системные ресурсы, повторно используя уже
созданные объекты, вместо порождения новых.  

Преимущества и недостатки

Преимущества
1. Избавляет класс от привязки
   к конкретным классам
   продуктов.
2. Выделяет код производства
   продуктов в одно место,
   упрощая поддержку кода.
3. Упрощает добавление новых
   продуктов в программу.
4. Реализует принцип
   открытости/закрытости.

Недостатки
5. Иногда приводит к созданию
   больших параллельных иерархий
   классов, так как для каждого
   класса продукта надо создать
   свой подкласс создателя.
</details>

Три причины почему нужно использовать этот паттерн.  

1. Объект определяется во время исполнения то-есть в runtime.  
Когда объект заранее не известен.

2. Паттерн выполняет принцип SOLID open close principle,
который говорит что классы должны быть открыты для расширения,
но закрыты для модификации.  
Возможность безопасно менять объекты. 

3. Повторное использование наработанного функционала.  

[Java Factory Method Фабричный Метод | Design Patterns](https://www.youtube.com/watch?v=X5G67aWO7CA&list=PLKP3l9fd3KUFbrccxZMI0z3CgRdBDCp-g)  
[Factory Method Pattern | В чем суть?](https://habr.com/ru/articles/556512/)  
[Factory Patterns - Simple Factory Pattern](https://www.codeproject.com/Articles/1131770/Factory-Patterns-Simple-Factory-Pattern)

### Объектно-ориентированные паттерны

[Паттерны проектирования программ на языке Java](https://www.youtube.com/playlist?list=PLKP3l9fd3KUFbrccxZMI0z3CgRdBDCp-g)  

### SOLID

SRP: Single Responsibility Principle. Принцип единственной ответственности  
OCP: Open-Closed Principle. Принцип открытости или закрытости  
LSP: Liskov Substitution Principle. Принцип подстановки Барбары Лисков  
ISP: Interface Segregation Principle. Принцип разделения интерфейсов  
DIP: Dependency Inversion Principle. Принцип инверсии зависимости  

SRP:  
Один класс-метод делает одно действие  
OCP:   
Класс открыт для расширений, но закрыт от модификаций  
LSP:  
Обратно совместимый и переносимый код  
ISP:   
Не надо делать интерфейсы с огромным количеством методов разных по ответственности  
DIP:  
Использовать интерфейсы что-бы не допустить циклических зависимостей между классами  

## Связанность и сочетаемость

>Низкая связанность и высокая сочетаемость являются целевыми
> аспектами хорошего проектирования программного обеспечения.
> 
>Низкая связанность означает, что компоненты или модули в 
> системе имеют минимальную зависимость друг от друга. 
> Каждый компонент должен иметь четко определенную ответственность 
> и не должен иметь излишних зависимостей от других компонентов. 
> Поддержание низкой связанности облегчает изменение и тестирование 
> компонентов, поскольку изменения в одном компоненте не влияют на другие 
> компоненты. Кроме того, низкая связанность способствует повторному 
> использованию компонентов в других частях системы или в других проектах.  
> 
>Высокая сочетаемость означает, что компоненты или модули в 
> системе могут быть легко переиспользованы или заменены без 
> влияния на остальную систему. Компоненты с высокой сочетаемостью 
> обеспечивают четко определенный интерфейс, который позволяет 
> другим компонентам взаимодействовать с ними. 
> Это делает систему более гибкой и масштабируемой, 
> поскольку компоненты могут быть комбинированы и заменены без
> необходимости изменения других компонентов.  
> 
>Для достижения низкой связанности и высокой сочетаемости, 
> рекомендуется следовать принципам SOLID 
> (Single Responsibility, Open/Closed, Liskov Substitution, 
> Interface Segregation, Dependency Inversion) 
> и использовать хорошо определенные интерфейсы и 
> абстракции для взаимодействия между компонентами. 
> Также полезно разделить систему на модули или слои 
> с четко определенными ответственностями и минимальными 
> зависимостями между ними.

#### Принципы архитектуры

Да, это тот самый SOLID, и более глубокие, связанные с ними принципы построения архитектуры

Эти базовые принципы применимы к любой парадигме программирования и любому виду ПО, т.к. по своей сути, они описывают правила поведения для логически завершенных объединений значений и функций, которые в ООП, например, являются классами

SRP - Single Responsibility Principle

Принцип единственной ответственности

OCP - Open-Close Principle

LSP - Liskov Substitution Principle

ISP - Interface Segregation Principle

DIP - Dependecy Inversion Principle

### Принципы связности

REP - Reuse/Release Equivivalence Pronciple

Принцип эквивалентности повторного использования и выпусков

Классы и модули, составляющие один общий логический компонент, должны принадлежать одной связанной группе. Обязательно должная быть общая тема/цель/функционал, объединяющие все элементы компонента

Аналогично для релизов компонента - все его составляющие должны входить в этот релиз. Т.е. нельзя выпустить библиотеку для стриминга аудио без поддержки сетевой части этого стриминга

Является включительным, т.к. говорит о  правиле объединении множества объектов в компонент

CCP - Common Closure Principle

Принцип согласованного изменения

Пересекается с Single Responsibility Principle в рамках одного компонента. Для изменения компонента должна быть всегда одна и только одна конкретная причина. Схож с REP и детальнее раскрывает связность - в рамках компонента должны объединяться классы, которые могут быть изменены по одной общей причине в одно время. В результате мы получаем лучшее деление на компоненты и меньшие трудозатраты по изменению/расширению функционала

Является включительным, т.к. говорит о  правиле объединении множества объектов в компонент

CRP - Common Reuse Principle

Принцип совместного повторного использования

Определяет правило включения классов/модулей в один общий компонент по принципу - компонент может зависеть только от тех объектов, функционал которых он использует, не должно быть лишних зависимостей, в лучшем случае компонент должен зависеть только от объектов, функции которых используются полностью (или хотя бы относятся по своему смыслу исключительно к задачам компонента).

Нарушение принципа ведет к появлению лишних не используемых зависимостей (функций) в компоненте ведет к ситуации когда изменения в подключенной к компоненту зависимости ведут за собой изменения в самом компоненте, что необходимо исключать в правильной архитектуре

Является обобщенной версией принципа ISP, т.к. так же является исключительным, и стремиться к уменьшению компонентов

В итоге получается противоречие между принципами REP/CCP и CRP. Первые два включительные и стремятся к увеличению компонента через объединение его частей по правилам, а второй наоборот говорит об исключении лишних зависимостей. Отсюда получается, что одна из главных задач архитектора - поиск баланса между этими принципами, исходя из условий задачи

**Важно помнить:**

- **В начале разработки баланс обычно смещен в пользу CCP и дешевле пожертвовать повторным использование в угоду скорости и удобства разработки, по мере развития проекта уклон будет уже в пользу CRP т.к. все больше компонентов будут переиспользоваться и его необходимо соблюдать для большей гибкости в поддержке и расширении**
- **Баланс между соблюдением тех или иных принципов постоянно смещается, это нормально и за этим необходимо следить, т.к. удачное разбиение компонентов на первом этапе развития приложения, может быть неактуальным в дальнейшем и компоненты будут постоянно меняться с течением времени**

### Принципы сочетаемости компонентов

И снова важен баланс - принципы проектирования могут противоречить или ограничивать друг друга и то, в какую сторону какого принципа вести дизайн больше - зависит от задач, контекста и планов развития проекта

#### ADP - Acyclic Dependecies Princilple Принцип ацикличности зависимостей

Принцип ацикличности зависимостей - недопустимы циклы в графе зависимостей, самый простой пример - ошибка с циклической зависимостью при сборке графа Dagger 2

Ацикличный граф не только уменьшает количество вероятных ошибок, но и сокращает количество ненужных зависимостей позволяет пройти полный путь по графу зависимостей от начала и до конца. Т.е. мы всегда знаем и быстро определяем всю цепочку зависимостей, в которой присутствует класс/копонент/модель и т.д.

Такой граф зависимостей - Ациклически ориентированный (Directed Acyclic Graph)

Как создать/поддержать такой граф зависимостей или исправить цикл:

- Воспользоваться DIP и развернуть поток управления той зависимости, которая приводит к циклу, самое простое - закрыть за интерфейсом и делегировать реализацию в нужный компонент
- Создать новый компонент, от которого будут зависеть те компоненты, которые ранее создавали данную циклическую зависимость

#### SDP - Staple Dependecies Principle Принцип устойчивых зависимостей

Устойчивость в данном ключе можно расшифровать как сложность изменения компонента. Может показаться, что устойчивым должен быть объект с минимумом зависящих от него компонентов, но на самом деле все наоборот:

Чем больше больше объектов зависит от компонента, тем больше согласованных изменений в нем нужно произвести, т.е. повышает сложность его изменения, а значит и устойчивость

Отсюда и наоборот - чем меньше от компонента звисит, тем менее он устойчив и легче поддается изменениям

I = F-in / (F-in - F-out)

I -  устойчивость от 0 до 1 (где 0 - максимальная устойчивость)

F-in - количество объектов, зависящих от компонента

F-out - количество объектов, от которых зависит компонент

Для чего все это?

Для основы принципа SDP - устойчивость компонента должна быть больше устойчивости компонентов, от которых он зависит. Метрика устойчивость должна уменьшаться в направлении зависимости. От самых неустойчивых к самым стабильным.

Например компоненты Android SDK можно считать более устойчивыми по отношению к компонентам разрабатываемого приложения. Core модуль приложения так же более устойчив (в правильной реализации архитектуры), и от него зависят менее устойчивые модули, по типу сетевой части, которая использует его базовый инструментарий

api service → network tooling → core

Где core - самый устойчивый, а api service - самый неустойчивый

Отсюда выходит ограничение - устойчивые компоненты не должны содержать зависимостей от неустойчивых, то есть в core модуль не должен зависеть от конкретных моделей api service

#### SAP - Stable Abstractions Principle Принцип устойчивости абстракций

Абстрактность компонента должна быть пропорциональная его устойчивости

Устойчивый компонент, это может быть и хорошо, но как в такой ситуации сделать его достаточно гибким? Использовать абстракции, которые позволят сделать компонент более податливым к расширению функционала, что будет соответствовать принципу OCP SOLID

Наиболее поддающийся к расширению компонент будет содержать больше интерфейсов и абстрактных классов

Чаща весов:

Устойчивость против Абстрактности

**Снова дело в балансе**

- Чем более устойчивые и менее абстрактные компоненты, тем сложнее их расширить, это самые неповоротливые части системы. Но такие компоненты тоже имеют место быть - базовые классы SDK, базы данных, низкоуровневые инструменты с минимумом зависимостей, это меняется с очень небольшой вероятностью
- С другой стороны чем менее устойчивые и более абстрактные компоненты - тем меньше пользы они приносят и меньше используются в проекте, вплоть до того, что это могут быть просто забытые и неиспользуемые интерефейсы и классы

Выход так, что где-то по середине должен быть баланс Устойчивости и абстрактности, и он идет таким образом

Чем более абстрактный компонент - тем более он должен быть устойчивый, и наоборот - менее устойчивый - значит менее абстрактный, то есть более конкретный

Снова пример из структуры

api service → network tooling → core

Здесь в api service содержатся более конкретные модели данных, конкретные реализации сетевых интерфейсов, которые менее устойчивы, по сравнению с абстракциями этих интерфейсов в network tooling

**Интересная мысль из книги:**

**Цель формы/структуры архитектуры - упростить разработку, деплой и сопровождение системы, где главная стратегия упрощения заключается в том, чтобы и дальше можно было иметь больше вариантов и гибкости**

### Паттерны доступа к данным

Data Access Object (DAO)
Row Data Gateway
Active Record
Table Data Gateway
Data Mapper
Repository (Репозиторий)
Domain Model (Модель предметной области)
Service Layer (Слой служб)
Data Transfer Object (Объект передачи данных)